<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Agent Minesweeper - Keyboard Tactical</title>
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
.bg-gauntlet {
  background: radial-gradient(circle at center, #170050, #000000);
  --bs-bg-opacity: 1;
  color: #00ffcc;
  font-family: 'Courier New', monospace;
  min-height: 100vh;
}

h1, h3, h4 {
  text-transform: uppercase;
  font-weight: 700;
  color: #00ffcc;
  text-align: center;
}

.mission-title {
  color: #00ffcc;
  font-family: 'Courier New', monospace;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 2px;
  text-shadow: 0 0 10px #00ffee;
  margin-bottom: 4rem;
  margin-top: 3rem;
}

.welcome {
  text-shadow: 0 0 10px #00ffee;
}

.btn-info {
  background-color: #003344;
  border-color: #007777;
  color: #00ffee;
  font-weight: bold;
  text-transform: uppercase;
  margin-top: 30px;
}

.btn-info:hover {
  background-color: #004c5c;
  color: #fff;
}

.btn-success {
  background-color: #003f3f;
  border-color: #00ffaa;
  color: #00ffaa;
  margin-top: .5em;
  text-transform: uppercase;
  font-weight: bold;
  letter-spacing: 1px;
  font-family: 'Courier New', monospace;
}

.btn-success:hover {
  background-color: #006f6f;
  color: white;
}

.noir {
  display: block;
  margin-left: auto;
  margin-right: auto;
  width: 200px;
  height: auto;
  border-radius: 15px;
}

#storyOverlay {
  background-color: rgba(0, 0, 0, 0.75);
  backdrop-filter: blur(2px);
}

#storyModal {
  background: radial-gradient(#001f2f, #000);
  border: 2px solid #00ffee;
  box-shadow: 0 0 30px #00ffee;
  color: #00ffee;
  font-family: 'Courier New', monospace;
  text-align: center;
}

.difficulty-selector {
  margin-top: 3rem;
}

.difficulty-btn {
  background: linear-gradient(145deg, #003344, #001122);
  border: 2px solid #00ffcc;
  color: #00ffcc;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 2px;
  padding: 15px 25px;
  margin: 0.5rem;
  transition: all 0.3s ease;
  box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
  min-width: 180px;
}

.difficulty-btn:hover {
  background: linear-gradient(145deg, #004455, #002233);
  border-color: #00ffee;
  color: #00ffee;
  box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
  transform: translateY(-2px);
}

#maze {
  display: inline-grid;
  gap: 1px;
  background: #0a0a0a;
  border: 3px solid #00ffcc;
  box-shadow: 0 0 30px rgba(0, 255, 204, 0.3);
  padding: 2px;
}

.cell {
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 2px outset #555;
  background: linear-gradient(145deg, #2a2a2a, #1a1a1a);
  font-weight: bold;
  font-size: 1rem;
  user-select: none;
  transition: all 0.15s ease;
  position: relative;
}

.cell.revealed {
  background: linear-gradient(145deg, #1a1a1a, #0a0a0a);
  border: 1px solid #333;
  border-style: inset;
}

.cell.player {
  box-shadow: 0 0 15px rgba(0, 255, 204, 1);
  border-color: #00ffcc;
  animation: playerPulse 1s infinite;
}

@keyframes playerPulse {
  0%, 100% { box-shadow: 0 0 10px rgba(0, 255, 204, 0.8); }
  50% { box-shadow: 0 0 20px rgba(0, 255, 204, 1); }
}

.cell.mine-hit {
  background: radial-gradient(circle, #ff0000, #990000) !important;
  animation: mineExplode 0.5s ease;
}

@keyframes mineExplode {
  0% { transform: scale(1); }
  50% { transform: scale(1.4); box-shadow: 0 0 40px red; }
  100% { transform: scale(1); }
}

.cell.flagged::before {
  content: 'üö©';
  position: absolute;
  font-size: 1.1rem;
  z-index: 2;
}

.cell.player-flagged::after {
  content: 'üïµÔ∏è';
  position: absolute;
  font-size: 1.3rem;
  z-index: 3;
  filter: drop-shadow(0 0 3px #00ffcc);
}

/* Number colors - classic minesweeper */
.num-1 { color: #00ffff; text-shadow: 0 0 5px #00ffff; }
.num-2 { color: #00ff00; text-shadow: 0 0 5px #00ff00; }
.num-3 { color: #ffff00; text-shadow: 0 0 5px #ffff00; }
.num-4 { color: #ff9900; text-shadow: 0 0 5px #ff9900; }
.num-5 { color: #ff6600; text-shadow: 0 0 5px #ff6600; }
.num-6 { color: #ff3300; text-shadow: 0 0 5px #ff3300; }
.num-7 { color: #ff0000; text-shadow: 0 0 5px #ff0000; }
.num-8 { color: #ff00ff; text-shadow: 0 0 5px #ff00ff; }

.mine-icon {
  font-size: 1.2rem;
}

.stats-panel {
  background: rgba(0, 20, 40, 0.9);
  border: 2px solid #00ffcc;
  border-radius: 10px;
  padding: 1.5rem;
  box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
}

.stat-item {
  display: flex;
  justify-content: space-between;
  margin: 0.5rem 0;
  font-size: 1.1rem;
  color: #00ffcc;
}

.stat-value {
  font-weight: bold;
  color: #00ff88;
}

.btn-tactical {
  background: linear-gradient(145deg, #003344, #001122);
  border: 2px solid #00ffcc;
  color: #00ffcc;
  font-weight: bold;
  text-transform: uppercase;
  letter-spacing: 2px;
  padding: 12px 30px;
  transition: all 0.3s ease;
  box-shadow: 0 0 15px rgba(0, 255, 204, 0.3);
}

.btn-tactical:hover {
  background: linear-gradient(145deg, #004455, #002233);
  border-color: #00ffee;
  color: #00ffee;
  box-shadow: 0 0 25px rgba(0, 255, 204, 0.5);
  transform: translateY(-2px);
}

.game-over-panel {
  background: rgba(0, 0, 0, 0.95);
  border: 3px solid #ff0000;
  border-radius: 15px;
  padding: 2rem;
  box-shadow: 0 0 40px rgba(255, 0, 0, 0.5);
}

.game-win-panel {
  background: rgba(0, 0, 0, 0.95);
  border: 3px solid #00ff00;
  border-radius: 15px;
  padding: 2rem;
  box-shadow: 0 0 40px rgba(0, 255, 0, 0.5);
}

.cascade-reveal {
  animation: cascadeFlash 0.2s ease;
}

@keyframes cascadeFlash {
  0% { background: #00ffcc; transform: scale(1.1); }
  100% { background: transparent; transform: scale(1); }
}

#timer {
  font-family: 'Courier New', monospace;
  font-size: 1.5rem;
  color: #00ffcc;
  text-shadow: 0 0 10px #00ffcc;
}

.controls-grid {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 0.5rem;
  margin-top: 1rem;
  font-size: 0.85rem;
}

.control-item {
  background: rgba(0, 50, 70, 0.5);
  padding: 0.5rem;
  border-radius: 5px;
  border: 1px solid #004466;
}

.kbd {
  background: #001122;
  padding: 2px 6px;
  border-radius: 3px;
  border: 1px solid #00ffcc;
  font-weight: bold;
  color: #00ffcc;
}

@keyframes screenShake {
  0%, 100% { transform: translate(0, 0); }
  25% { transform: translate(-5px, 0); }
  75% { transform: translate(5px, 0); }
}

.shake {
  animation: screenShake 0.3s ease;
}

/* Drone styles */
.cell.drone {
  background: #222 !important;
  border: 2px solid cyan !important;
  box-shadow: 0 0 15px cyan !important;
  animation: dronePulse 0.8s infinite;
}

@keyframes dronePulse {
  0%, 100% { box-shadow: 0 0 10px cyan; }
  50% { box-shadow: 0 0 20px cyan, 0 0 30px rgba(0, 255, 255, 0.5); }
}

/* Anomaly (mystery tile) styles */
.cell.anomaly {
  background: radial-gradient(circle, #9900ff, #4400aa) !important;
  border: 2px solid #ff00ff !important;
  animation: anomalyPulse 1.2s infinite;
}

@keyframes anomalyPulse {
  0%, 100% { 
    box-shadow: 0 0 10px #ff00ff;
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 25px #ff00ff, 0 0 40px rgba(255, 0, 255, 0.6);
    transform: scale(1.05);
  }
}

/* Proximity Mine styles */
.cell.proximity-mine {
  background: radial-gradient(circle, #ff3300, #990000) !important;
  border: 2px solid #ff6600 !important;
  animation: proximityPulse 0.6s infinite;
}

@keyframes proximityPulse {
  0%, 100% { 
    box-shadow: 0 0 15px #ff3300;
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 30px #ff3300, 0 0 50px rgba(255, 51, 0, 0.8);
    transform: scale(1.1);
  }
}

.notification {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.9);
  border: 2px solid #00ffcc;
  padding: 15px 30px;
  border-radius: 10px;
  font-weight: bold;
  font-size: 1.1rem;
  z-index: 10000;
  box-shadow: 0 0 20px rgba(0, 255, 204, 0.5);
  animation: slideDown 0.3s ease;
}

@keyframes slideDown {
  from { top: -100px; opacity: 0; }
  to { top: 20px; opacity: 1; }
}

.notification.danger {
  border-color: #ff0000;
  color: #ff0000;
  box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
}

.notification.success {
  border-color: #00ff00;
  color: #00ff00;
  box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
}

.notification.warning {
  border-color: #ffff00;
  color: #ffff00;
  box-shadow: 0 0 20px rgba(255, 255, 0, 0.5);
}

.notification.info {
  border-color: #ff00ff;
  color: #ff00ff;
  box-shadow: 0 0 20px rgba(255, 0, 255, 0.5);
}

/* Anomaly transformation effect */
.cell.anomaly-transform {
  animation: transformFlash 0.8s ease;
}

@keyframes transformFlash {
  0%, 100% { background: #9900ff; transform: scale(1) rotate(0deg); }
  25% { background: #ff00ff; transform: scale(1.3) rotate(90deg); }
  50% { background: #00ffff; transform: scale(1.5) rotate(180deg); }
  75% { background: #ff00ff; transform: scale(1.3) rotate(270deg); }
}

.badge {
  font-family: 'Courier New', monospace;
  font-size: 1rem;
  padding: 0.6rem 1rem;
  border-radius: 12px;
}

.anomaly-countdown {
  position: absolute;
  top: 2px;
  right: 2px;
  background: rgba(0, 0, 0, 0.8);
  color: #ff00ff;
  font-size: 0.7rem;
  padding: 1px 3px;
  border-radius: 3px;
  font-weight: bold;
  z-index: 5;
}

.proximity-countdown {
  position: absolute;
  top: 2px;
  right: 2px;
  background: rgba(0, 0, 0, 0.8);
  color: #ff3300;
  font-size: 0.7rem;
  padding: 1px 3px;
  border-radius: 3px;
  font-weight: bold;
  z-index: 5;
}

/* Static Interference */
.cell.interference {
  animation: staticFlicker 0.3s infinite;
}

@keyframes staticFlicker {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; background: #333; }
}

/* EMP Blackout */
.emp-blackout .cell.revealed {
  background: #000 !important;
  color: transparent !important;
  border-color: #111 !important;
}

.emp-blackout .cell.revealed::before,
.emp-blackout .cell.revealed::after {
  display: none !important;
}

/* Threat Level Bar */
.threat-bar {
  width: 100%;
  height: 20px;
  background: #001122;
  border: 2px solid #00ffcc;
  border-radius: 10px;
  overflow: hidden;
  margin-top: 1rem;
  position: relative;
}

.threat-fill {
  height: 100%;
  transition: width 0.5s ease, background-color 0.5s ease;
  border-radius: 8px;
}

.threat-level-0 { background: linear-gradient(90deg, #00ff00, #00cc00); width: 0%; }
.threat-level-1 { background: linear-gradient(90deg, #00ff00, #00cc00); width: 20%; }
.threat-level-2 { background: linear-gradient(90deg, #ffff00, #cccc00); width: 40%; }
.threat-level-3 { background: linear-gradient(90deg, #ff9900, #cc7700); width: 60%; }
.threat-level-4 { background: linear-gradient(90deg, #ff3300, #cc0000); width: 80%; }
.threat-level-5 { background: linear-gradient(90deg, #ff0000, #990000); width: 100%; animation: threatPulse 0.5s infinite; }

@keyframes threatPulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.7; }
}

.threat-label {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 0.7rem;
  font-weight: bold;
  color: #fff;
  text-shadow: 0 0 3px #000;
  pointer-events: none;
}

.flash-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: #000000;
  opacity: 0;
  z-index: 9999;
  pointer-events: none;
  transition: opacity 0.1s ease;
}

.cell.emp-powerup {
  background: radial-gradient(circle, #ffff00, #ffaa00) !important;
  border: 2px solid #ffff00 !important;
  animation: empPulse 0.8s infinite;
  box-shadow: 0 0 20px #ffff00 !important;
}

@keyframes empPulse {
  0%, 100% { 
    box-shadow: 0 0 15px #ffff00;
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 30px #ffff00, 0 0 50px rgba(255, 255, 0, 0.6);
    transform: scale(1.1);
  }
}

.cell.emp-trap-bomb {
  background: radial-gradient(circle, #ff0000, #8b0000) !important;
  border: 2px solid #ff0000 !important;
  animation: trapBombPulse 0.6s infinite;
}

@keyframes trapBombPulse {
  0%, 100% { 
    box-shadow: 0 0 10px #ff0000;
  }
  50% { 
    box-shadow: 0 0 20px #ff0000, 0 0 30px rgba(255, 0, 0, 0.5);
  }
}

/* Chaos mode screen effects */
.chaos-mode-active {
  animation: chaosShake 0.5s infinite;
}

.cell.blue-hazard {
  background: radial-gradient(circle, #0099ff, #0055aa) !important;
  border: 2px solid #00ccff !important;
  animation: blueHazardPulse 0.8s infinite;
}

@keyframes blueHazardPulse {
  0%, 100% { 
    box-shadow: 0 0 15px #0099ff;
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 30px #0099ff, 0 0 50px rgba(0, 153, 255, 0.6);
    transform: scale(1.05);
  }
}

.cell.green-hazard {
  background: radial-gradient(circle, #00ff66, #00aa44) !important;
  border: 2px solid #00ff88 !important;
  animation: greenHazardPulse 0.8s infinite;
}

@keyframes greenHazardPulse {
  0%, 100% { 
    box-shadow: 0 0 15px #00ff66;
    transform: scale(1);
  }
  50% { 
    box-shadow: 0 0 30px #00ff66, 0 0 50px rgba(0, 255, 102, 0.6);
    transform: scale(1.05);
  }
}

@keyframes chaosShake {
  0%, 100% { transform: translate(0, 0) rotate(0deg); }
  25% { transform: translate(-3px, 3px) rotate(-0.5deg); }
  75% { transform: translate(3px, -3px) rotate(0.5deg); }
}
  </style>
</head>
<body class="bg-gauntlet text-white">

  <!-- Lobby Screen -->
  <div class="container-fluid py-4" id="lobbyScreen">
    <button class="btn btn-tactical w-100 mt-2" id="singlePlayerBtn" style="max-width: 300px; margin: 0 auto 2rem auto; display: block;">
      üéÆ SINGLE PLAYER MODE
    </button>

    <h1 class="mission-title">MULTIPLAYER COMMAND CENTER</h1>
    
    <div class="row justify-content-center" id="lobbyMenu">
      <div class="col-md-6">
        <div class="stats-panel">
          <h4 class="text-center mb-4" style="color: #00ffcc;">AGENT IDENTIFICATION</h4>
          <input type="text" id="playerName" class="form-control mb-3" 
                 style="background: #001122; border: 2px solid #00ffcc; color: #00ffcc;"
                 placeholder="Enter Agent Name" maxlength="15">
          
          <button class="btn btn-tactical w-100 mb-2" id="createLobbyBtn">
            üéÆ CREATE NEW LOBBY
          </button>
          
          <hr style="border-color: #00ffcc;">
          
          <h5 class="text-center" style="color: #00ffcc;">OR JOIN EXISTING</h5>
          <input type="text" id="lobbyCodeInput" class="form-control mb-3" 
                 style="background: #001122; border: 2px solid #00ffcc; color: #00ffcc; text-transform: uppercase;"
                 placeholder="Enter 6-Digit Lobby Code" maxlength="6">
          <button class="btn btn-tactical w-100" id="joinLobbyBtn">
            üö™ JOIN LOBBY
          </button>
        </div>
      </div>
    </div>
    
    <!-- Lobby Waiting Room -->
    <div class="row justify-content-center d-none" id="lobbyWaiting">
      <div class="col-md-6">
        <div class="stats-panel">
          <h4 class="text-center" style="color: #00ffcc;">LOBBY: <span id="currentLobbyCode" style="color: #00ff88;"></span></h4>
          <p class="text-center" style="color: #00ff88;">
            Share this code with agents to join!
          </p>
          
          <h5 class="text-center mt-4" style="color: #00ffcc;">AGENTS IN LOBBY:</h5>
          <ul id="lobbyPlayerList" class="list-unstyled text-center">
          </ul>
          
          <button class="btn btn-success w-100 mt-3 d-none" id="startGameBtn">
            ‚ñ∂Ô∏è START MISSION
          </button>
          <button class="btn btn-tactical w-100 mt-2" id="leaveLobbyBtn">
            ‚ùå LEAVE LOBBY
          </button>
        </div>
      </div>
    </div>
  </div>
  
  <!-- Title Screen -->
  <div class="container-fluid py-4 d-none" id="titleScreen">
    <h1 class="welcome">You Have Reached: The MineField</h1>
    <h1 class="mission-title">YOUR MISSION: ENTER THE GAUNTLET</h1>
    <h3 id="mission">Objective: Clear The Field, Discover The Mines</h3>
    
    <div class="text-center difficulty-selector">
      <h4 class="mb-3" style="color: #00ffcc;">SELECT DIFFICULTY</h4>
      <button class="difficulty-btn" data-difficulty="beginner">
        BEGINNER<br><small style="font-size: 0.75rem;">10x10 Grid | 12 Mines</small>
      </button>
      <button class="difficulty-btn" data-difficulty="intermediate">
        INTERMEDIATE<br><small style="font-size: 0.75rem;">16x16 Grid | 40 Mines</small>
      </button>
      <button class="difficulty-btn" data-difficulty="expert">
        EXPERT<br><small style="font-size: 0.75rem;">22x22 Grid | 99 Mines</small>
      </button>
    </div>

    <div class="text-center mt-4">
      <button id="openStoryBtn" class="btn btn-info mt-3">For Agent 5 Only üìñ</button>
    </div>
  </div>

  <!-- Story Overlay -->
  <div id="storyOverlay" class="position-fixed top-0 start-0 w-100 h-100 bg-black" style="opacity: 0.6; display: none; z-index: 1000;"></div>
  
  <!-- Story Modal -->
  <div id="storyModal" class="position-fixed top-50 start-50 translate-middle bg-dark text-white border rounded p-4 shadow-lg" style="display:none; z-index: 1001; width: 400px; max-width: 90%;">
    <h4 id="storyTitle">Welcome Agent 5 (AKA The Minesweeper)</h4>
    <img class="noir" src="./static/Noir.png" alt="Agent Image" style="display:block; margin:0 auto; width:200px; border-radius:15px;">
    <p id="storyContent" style="min-height: 120px;"></p>
    <div class="text-end">
      <button id="nextBtn" class="btn btn-warning">Next</button>
      <button id="closeStoryBtn" class="btn btn-secondary">Close</button>
    </div>
  </div>

  <!-- Game Screen -->
  <div class="container-fluid py-4 d-none" id="gameScreen">
    <div class="row justify-content-center">
      
      <!-- Stats Panel -->
      <div class="col-auto">
        <div class="stats-panel" style="width: 240px;">
          <h5 class="text-center mb-3" style="color: #00ffcc;">üìä MISSION STATUS</h5>
          
          <div class="stat-item">
            <span>üí£ Total Mines:</span>
            <span class="stat-value" id="mineCount">0</span>
          </div>
          
          <div class="stat-item">
            <span>üö© Flags Placed:</span>
            <span class="stat-value" id="flagCount">0</span>
          </div>
          
          <div class="stat-item">
            <span>‚è±Ô∏è Time:</span>
            <span class="stat-value" id="timer">000</span>
          </div>
          
          <div class="stat-item">
            <span>üìç Tiles Left:</span>
            <span class="stat-value" id="tilesLeft">0</span>
          </div>

          <div class="stat-item">
            <span>üéØ Streak:</span>
            <span class="stat-value" id="streakCount">0</span>
          </div>

          <div class="stat-item">
            <span>‚ö° EMP Charges:</span>
            <span class="stat-value" id="empCharges">1</span>
          </div>

          <div class="threat-bar">
            <div class="threat-fill threat-level-0" id="threatFill"></div>
            <div class="threat-label" id="threatLabel">SAFE</div>
          </div>

          <hr style="border-color: #00ffcc;">
          
          <button class="btn btn-tactical w-100 mb-2" id="newGameBtn">
            üè† NEW MISSION
          </button>

          <div class="controls-grid">
            <div class="control-item">
              <span class="kbd">SPACE</span> Scan
            </div>
            <div class="control-item">
              <span class="kbd">F</span> Flag
            </div>
            <div class="control-item">
              <span class="kbd">‚Üë‚Üì‚Üê‚Üí</span> Move
            </div>
            <div class="control-item">
              <span class="kbd">R</span> Restart
            </div>
            <div class="control-item">
              <span class="kbd">E</span> Use EMP
            </div>
          </div>
        </div>
      </div>

      <!-- Game Board -->
      <div class="col-auto">
        <div class="d-flex justify-content-center align-items-center" style="min-height: 70vh;">
          <div id="maze"></div>
        </div>
      </div>

    </div>
  </div>

  <!-- Game Over Modal -->
  <div class="modal fade" id="gameOverModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content game-over-panel">
        <div class="modal-body text-center">
          <h2 style="color: #ff0000;">üí• MISSION FAILED üí•</h2>
          <p class="mt-3" style="font-size: 1.2rem;">You triggered a mine!</p>
          <p style="color: #888;">Survival Time: <span id="failTime">0</span>s</p>
          <p style="color: #888;">Streak: <span id="failStreak">0</span></p>
          <button class="btn btn-tactical mt-3" data-bs-dismiss="modal" id="retryBtn">
            üîÑ TRY AGAIN
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Win Modal -->
  <div class="modal fade" id="gameWinModal" tabindex="-1">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content game-win-panel">
        <div class="modal-body text-center">
          <h2 style="color: #00ff00;">‚úÖ MISSION COMPLETE ‚úÖ</h2>
          <p class="mt-3" style="font-size: 1.2rem;">All mines successfully located!</p>
          <p style="color: #00ffcc; font-size: 1.8rem; font-weight: bold;">
            ‚è±Ô∏è <span id="winTime">0</span>s
          </p>
          <p style="color: #ffff00; font-size: 1.3rem;">
            üéØ Final Streak: <span id="winStreak">0</span>
          </p>
          <button class="btn btn-tactical mt-3" data-bs-dismiss="modal" id="playAgainBtn">
            üéÆ PLAY AGAIN
          </button>
        </div>
      </div>
    </div>
  </div>

  <div id="flash" class="flash-overlay"></div>

<script>
  // ============================================================================
// MULTIPLAYER WEBSOCKET & LOBBY SYSTEM
// ============================================================================

let socket = null;
let myPlayerId = null;
let currentLobbyCode = null;
let isHost = false;
let otherPlayers = {};
let isMultiplayer = false;

// Game state tracking
let currentScreen = 'lobby'; // Can be: 'lobby', 'title', 'game'

// ============================================================================
// GAME STATE VARIABLES
// ============================================================================

let grid = [];
let rows = 0;
let cols = 0;
let mineCount = 0;
let flagCount = 0;
let revealedCount = 0;
let gameOver = false;
let gameWon = false;
let timerInterval = null;
let timeElapsed = 0;
let firstClick = true;
let playerRow = 0;
let playerCol = 0;
let isTyping = false;
let typingInterval = null;

let moveCooldown = false;
const MOVE_DELAY = 115;

let droneRow = -1;
let droneCol = -1;
let droneActive = false;
let droneInterval = null;
let droneSpawnTimer = null;

let empCharges = 1;
let empPowerupActive = false;
let empPowerupRow = -1;
let empPowerupCol = -1;
let empPowerupSpawnTimer = null;
let empTrapBombs = [];
let empPowerupTimeout = null;

let drone2Row = -1;
let drone2Col = -1;
let drone2Active = false;
let drone2Interval = null;
let drone2SpawnTimer = null;

let anomalyRow = -1;
let anomalyCol = -1;
let anomalyActive = false;
let anomalySpawnTimer = null;
let anomalySpawnInterval = 25000;
let anomalyCountdown = 0;
let anomalyCountdownInterval = null;

let proximityMines = [];
let proximitySpawnTimer = null;

let staticInterferenceActive = false;
let staticInterferenceTimer = null;
let interferenceCells = [];

let empBlackoutActive = false;
let empBlackoutTimer = null;

let hazardTiles = [];
let hazardSpawnTimer = null;
let playerSlowed = false;
let playerFrozen = false;

let streak = 0;
let threatLevel = 0;

const difficulties = {
  beginner: { rows: 10, cols: 10, mines: 12 },
  intermediate: { rows: 16, cols: 16, mines: 40 },
  expert: { rows: 22, cols: 22, mines: 99 }
};



function connectToServer() {
  console.log('Attempting to connect to WebSocket server...');
  socket = new WebSocket('ws://localhost:8080');
  
  socket.onopen = () => {
    console.log('‚úÖ Connected to server!');
  };
  
  socket.onmessage = (event) => {
    console.log('Message from server:', event.data);
    const data = JSON.parse(event.data);
    handleServerMessage(data);
  };
  
  socket.onerror = (error) => {
    console.error('‚ùå WebSocket error:', error);
    showNotification('Failed to connect to server!', 'danger');
  };
  
  socket.onclose = () => {
    console.log('Disconnected from server');
  };
}

function handleServerMessage(data) {
  console.log('Handling message:', data.type);
  
  switch(data.type) {
    case 'LOBBY_CREATED':
      currentLobbyCode = data.lobbyCode;
      isHost = data.isHost;
      myPlayerId = data.playerId;
      
      document.getElementById('lobbyMenu').classList.add('d-none');
      document.getElementById('lobbyWaiting').classList.remove('d-none');
      document.getElementById('currentLobbyCode').textContent = data.lobbyCode;
      
      if (isHost) {
        document.getElementById('startGameBtn').classList.remove('d-none');
      }
      
      updateLobbyPlayerList(data.players);
      showNotification(`Lobby ${data.lobbyCode} created!`, 'success');
      break;
      
    case 'JOINED_LOBBY':
      myPlayerId = data.playerId;
      break;
      
    case 'PLAYER_JOINED':
      updateLobbyPlayerList(data.players);
      showNotification(`${data.newPlayer} joined the lobby!`, 'info');
      break;
      
    case 'PLAYER_LEFT':
      updateLobbyPlayerList(data.players);
      
      if (data.newHost === myPlayerId) {
        isHost = true;
        document.getElementById('startGameBtn').classList.remove('d-none');
        showNotification('You are now the host!', 'warning');
      }
      break;
      
    case 'GAME_STARTED':
      isMultiplayer = true;
      initializeMultiplayerGame(data);
      break;
      
    case 'PLAYER_MOVED':
      if (data.playerId !== myPlayerId) {
        if (!otherPlayers[data.playerId]) {
          otherPlayers[data.playerId] = {};
        }
        otherPlayers[data.playerId].row = data.row;
        otherPlayers[data.playerId].col = data.col;
        renderGrid();
      }
      break;
      
    case 'TILES_REVEALED':
      data.cells.forEach(cell => {
        if (grid[cell.row] && grid[cell.row][cell.col]) {
          grid[cell.row][cell.col].revealed = true;
          grid[cell.row][cell.col].adjacentMines = cell.adjacentMines;
          if (!grid[cell.row][cell.col].mine) {
            revealedCount++;
          }
        }
      });
      
      if (data.playerId === myPlayerId) {
        streak++;
      }
      
      renderGrid();
      updateStats();
      break;
      
    case 'PLAYER_HIT_MINE':
      if (grid[data.row] && grid[data.row][data.col]) {
        grid[data.row][data.col].revealed = true;
        grid[data.row][data.col].mine = true;
      }
      
      if (data.playerId === myPlayerId) {
        gameOver = true;
        streak = 0;
        document.body.classList.add('shake');
        setTimeout(() => document.body.classList.remove('shake'), 300);
        stopTimer();
        clearAllTimers();
        renderGrid();
        showGameOver();
      } else {
        showNotification(`${data.playerName} hit a mine!`, 'danger');
        if (otherPlayers[data.playerId]) {
          otherPlayers[data.playerId].alive = false;
        }
      }
      renderGrid();
      break;
      
    case 'FLAG_TOGGLED':
      if (grid[data.row] && grid[data.row][data.col]) {
        grid[data.row][data.col].flagged = data.flagged;
        flagCount += data.flagged ? 1 : -1;
        renderGrid();
        updateStats();
      }
      break;
      
    case 'GAME_WON':
      gameWon = true;
      stopTimer();
      clearAllTimers();
      renderGrid();
      updateStats();
      showGameWin();
      break;
      
    case 'ERROR':
      showNotification(data.message, 'danger');
      break;
  }
}

function updateLobbyPlayerList(players) {
  const list = document.getElementById('lobbyPlayerList');
  list.innerHTML = '';
  
  players.forEach((player, index) => {
    const li = document.createElement('li');
    li.style.color = '#00ffcc';
    li.style.fontSize = '1.2rem';
    li.style.margin = '0.5rem 0';
    
    let text = `üïµÔ∏è ${player.name || player}`;
    if (index === 0) text += ' üëë (HOST)';
    
    li.textContent = text;
    list.appendChild(li);
  });
  
  if (isHost && players.length >= 1) {
    document.getElementById('startGameBtn').disabled = false;
  }
}

// ============================================================================
// LOBBY BUTTON HANDLERS
// ============================================================================

document.getElementById('createLobbyBtn').addEventListener('click', () => {
  const playerName = document.getElementById('playerName').value.trim();
  
  if (!playerName) {
    showNotification('Enter your agent name!', 'danger');
    return;
  }
  
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    connectToServer();
    setTimeout(() => {
      socket.send(JSON.stringify({
        type: 'CREATE_LOBBY',
        playerName: playerName,
        difficulty: 'intermediate',
        maxPlayers: 4
      }));
    }, 500);
  } else {
    socket.send(JSON.stringify({
      type: 'CREATE_LOBBY',
      playerName: playerName,
      difficulty: 'intermediate',
      maxPlayers: 4
    }));
  }
});

document.getElementById('joinLobbyBtn').addEventListener('click', () => {
  const playerName = document.getElementById('playerName').value.trim();
  const lobbyCode = document.getElementById('lobbyCodeInput').value.trim().toUpperCase();
  
  if (!playerName) {
    showNotification('Enter your agent name!', 'danger');
    return;
  }
  
  if (!lobbyCode || lobbyCode.length !== 6) {
    showNotification('Enter valid 6-digit lobby code!', 'danger');
    return;
  }
  
  if (!socket || socket.readyState !== WebSocket.OPEN) {
    connectToServer();
    setTimeout(() => {
      socket.send(JSON.stringify({
        type: 'JOIN_LOBBY',
        playerName: playerName,
        lobbyCode: lobbyCode
      }));
    }, 500);
  } else {
    socket.send(JSON.stringify({
      type: 'JOIN_LOBBY',
      playerName: playerName,
      lobbyCode: lobbyCode
    }));
  }
});

document.getElementById('startGameBtn').addEventListener('click', () => {
  socket.send(JSON.stringify({
    type: 'START_GAME'
  }));
});

document.getElementById('leaveLobbyBtn').addEventListener('click', () => {
  socket.send(JSON.stringify({
    type: 'LEAVE_LOBBY'
  }));
  
  document.getElementById('lobbyWaiting').classList.add('d-none');
  document.getElementById('lobbyMenu').classList.remove('d-none');
  currentLobbyCode = null;
  isHost = false;
});

document.getElementById('singlePlayerBtn').addEventListener('click', () => {
  currentScreen = 'title';
  isMultiplayer = false;
  document.getElementById('lobbyScreen').classList.add('d-none');
  document.getElementById('titleScreen').classList.remove('d-none');
});

// ============================================================================
// STORY MODAL
// ============================================================================

const storyText = `We know it's been 35 years since your last operation ‚Äî flagging and discovering the mines at Microsoft. But when it comes to those dreaded bombs, nobody can read them like you.

The agency needs you back, one last time. Your mission should you choose to accept it: infiltrate The Gauntlet ‚Äî a volatile, shifting maze laced with traps, misdirection, and everchanging shifting chaos. Every step could trigger the end. The layout changes. The danger adapts.

Outthink the field. Outsmart the traps. Outlive the maze.

Welcome back, Agent. The gauntlet is waiting.`;

function typeWriter(text, element, speed = 50, callback) {
  isTyping = true;
  element.textContent = '';
  let i = 0;
  clearInterval(typingInterval);

  typingInterval = setInterval(() => {
    if (i < text.length) {
      element.textContent += text.charAt(i);
      i++;
    } else {
      clearInterval(typingInterval);
      isTyping = false;
      if (callback) callback();
    }
  }, speed);
}

document.getElementById('openStoryBtn').addEventListener('click', () => {
  document.getElementById('storyModal').style.display = 'block';
  document.getElementById('storyOverlay').style.display = 'block';
  document.getElementById('storyTitle').textContent = 'Welcome Agent 5 (AKA The Minesweeper)';
  document.getElementById('nextBtn').textContent = 'Next';
  typeWriter(storyText, document.getElementById('storyContent'));
});

document.getElementById('closeStoryBtn').addEventListener('click', () => {
  clearInterval(typingInterval);
  isTyping = false;
  document.getElementById('storyModal').style.display = 'none';
  document.getElementById('storyOverlay').style.display = 'none';
});

document.getElementById('nextBtn').addEventListener('click', () => {
  clearInterval(typingInterval);
  isTyping = false;

  const title = document.getElementById('storyTitle');
  const content = document.getElementById('storyContent');

  if (title.textContent === 'Welcome Agent 5 (AKA The Minesweeper)') {
    title.textContent = 'The Mission Statement';
    content.innerHTML = 
      `üö© Use arrow keys to move<br>
      üí£ Avoid the red mines<br>
      üí• Press SPACE to scan tiles<br>
      üö© Press F to flag suspected mines<br>
      üõ∏ EVADE corporate drones - they never stop!<br>
      üí• Proximity mines EXPLODE if you're too close!<br>
      üîÆ Anomalies re-cover discovered areas<br>
      ‚ö° Static interference hides tile info<br>
      üåë EMP blackouts temporarily blind you<br>
      ‚ö†Ô∏è Numbers = exact mine count nearby<br>
      üéØ Build streaks by scanning safe tiles<br>
      ‚è∞ DANGER ESCALATES OVER TIME!<br>
      üîÑ Press R to restart<br><br>
      Use Logic And Deduction To Clear The Field<br><br>
    For Security Purposes The Rest Of The Information Has Been Omitted`;
    document.getElementById('nextBtn').textContent = 'Back';
  } else {
    title.textContent = 'Welcome Agent 5 (AKA The Minesweeper)';
    typeWriter(storyText, content);
    document.getElementById('nextBtn').textContent = 'Next';
  }
});

// ============================================================================
// DIFFICULTY SELECTION (SINGLE PLAYER)
// ============================================================================

document.querySelectorAll('.difficulty-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const difficulty = btn.dataset.difficulty;
    const config = difficulties[difficulty];
    currentScreen = 'game';
    isMultiplayer = false;
    startGame(config.rows, config.cols, config.mines);
  });
});

// ============================================================================
// GAME INITIALIZATION
// ============================================================================

function startGame(r, c, m) {
  rows = r;
  cols = c;
  mineCount = m;
  flagCount = 0;
  revealedCount = 0;
  gameOver = false;
  gameWon = false;
  timeElapsed = 0;
  firstClick = true;
  streak = 0;
  threatLevel = 0;
  droneActive = false;
  drone2Active = false;
  anomalyActive = false;
  staticInterferenceActive = false;
  empBlackoutActive = false;
  proximityMines = [];
  interferenceCells = [];
  empCharges = 1;
  empPowerupActive = false;
  empTrapBombs = [];
  hazardTiles = [];
  playerSlowed = false;
  playerFrozen = false;
  otherPlayers = {};
  
  playerRow = Math.floor(rows / 2);
  playerCol = Math.floor(cols / 2);

  currentScreen = 'game';
  
  document.getElementById('lobbyScreen').classList.add('d-none');
  document.getElementById('titleScreen').classList.add('d-none');
  document.getElementById('gameScreen').classList.remove('d-none');
  
  initializeGrid();
  renderGrid();
  updateStats();
  updateThreatLevel();
  
  clearAllTimers();
  
  schedulePhases();
}

function initializeMultiplayerGame(data) {
  console.log('Received game data:', data);
  
  const gridData = data.gridData;
  
  rows = gridData.rows;
  cols = gridData.cols;
  mineCount = gridData.mineCount;
  grid = gridData.grid;
  
  console.log('Set up game:', rows, 'x', cols, 'with', mineCount, 'mines');
  
  flagCount = 0;
  revealedCount = 0;
  gameOver = false;
  gameWon = false;
  timeElapsed = 0;
  firstClick = false;
  streak = 0;
  threatLevel = 0;
  droneActive = false;
  drone2Active = false;
  anomalyActive = false;
  staticInterferenceActive = false;
  empBlackoutActive = false;
  proximityMines = [];
  interferenceCells = [];
  empCharges = 1;
  empPowerupActive = false;
  empTrapBombs = [];
  hazardTiles = [];
  playerSlowed = false;
  playerFrozen = false;
  
  // Set up other players
  otherPlayers = {};
  data.players.forEach(p => {
    if (p.id === myPlayerId) {
      playerRow = p.row;
      playerCol = p.col;
    } else {
      otherPlayers[p.id] = {
        name: p.name,
        row: p.row,
        col: p.col,
        alive: p.alive
      };
    }
  });
  
  console.log('Player starting at:', playerRow, playerCol);
  console.log('Other players:', otherPlayers);

  currentScreen = 'game';
  
  document.getElementById('lobbyScreen').classList.add('d-none');
  document.getElementById('titleScreen').classList.add('d-none');
  document.getElementById('gameScreen').classList.remove('d-none');
  
  renderGrid();
  updateStats();
  updateThreatLevel();
  
  clearAllTimers();
  startTimer();
  schedulePhases();
}

function clearAllTimers() {
  if (timerInterval) clearInterval(timerInterval);
  if (droneInterval) clearInterval(droneInterval);
  if (droneSpawnTimer) clearTimeout(droneSpawnTimer);
  if (drone2Interval) clearInterval(drone2Interval);
  if (drone2SpawnTimer) clearTimeout(drone2SpawnTimer);
  if (anomalySpawnTimer) clearInterval(anomalySpawnTimer);
  if (anomalyCountdownInterval) clearInterval(anomalyCountdownInterval);
  if (proximitySpawnTimer) clearTimeout(proximitySpawnTimer);
  if (staticInterferenceTimer) clearInterval(staticInterferenceTimer);
  if (empBlackoutTimer) clearInterval(empBlackoutTimer);
  if (empPowerupSpawnTimer) clearInterval(empPowerupSpawnTimer);
  if (empPowerupTimeout) clearTimeout(empPowerupTimeout);
  if (hazardSpawnTimer) clearInterval(hazardSpawnTimer);
  
  document.body.classList.remove('chaos-mode-active');
  document.getElementById('maze').classList.remove('emp-blackout');
}

function schedulePhases() {
  setTimeout(() => {
    spawnEMPPowerup();
    empPowerupSpawnTimer = setInterval(() => {
      spawnEMPPowerup();
    }, 45000);
  }, 20000);
  
  droneSpawnTimer = setTimeout(() => {
    spawnDrone();
    threatLevel = 1;
    updateThreatLevel();
  }, 30000);
  
  setTimeout(() => {
    anomalySpawnTimer = setInterval(() => {
      spawnAnomaly();
    }, anomalySpawnInterval);
  }, 30000);
  
  setTimeout(() => {
    threatLevel = 2;
    updateThreatLevel();
    staticInterferenceTimer = setInterval(() => {
      triggerStaticInterference();
    }, 20000);
  }, 60000);
  
  proximitySpawnTimer = setTimeout(() => {
    spawnProximityMine();
  }, 75000);
  
  setTimeout(() => {
    threatLevel = 3;
    updateThreatLevel();
    empBlackoutTimer = setInterval(() => {
      triggerEMPBlackout();
    }, 40000);
    
    setTimeout(() => spawnProximityMine(), 15000);
  }, 90000);
  
  setTimeout(() => {
    threatLevel = 4;
    updateThreatLevel();
    clearInterval(anomalySpawnTimer);
    anomalySpawnInterval = 15000;
    anomalySpawnTimer = setInterval(() => {
      spawnAnomaly();
    }, anomalySpawnInterval);
  }, 120000);
  
  drone2SpawnTimer = setTimeout(() => {
    threatLevel = 5;
    updateThreatLevel();
    spawnDrone2();
    document.body.classList.add('chaos-mode-active');
    showNotification('üö® CHAOS MODE ACTIVATED! üö®', 'danger');
  }, 150000);

  setTimeout(() => {
    spawnHazardTile();
    hazardSpawnTimer = setInterval(() => {
      spawnHazardTile();
    }, 8000);
  }, 10000);
}

function updateThreatLevel() {
  const fill = document.getElementById('threatFill');
  const label = document.getElementById('threatLabel');
  
  fill.className = 'threat-fill threat-level-' + threatLevel;
  
  const labels = ['SAFE', 'ALERT', 'DANGER', 'HIGH ALERT', 'CRITICAL', 'CHAOS'];
  label.textContent = labels[threatLevel] || 'SAFE';
}

// ============================================================================
// GRID MANAGEMENT
// ============================================================================

function initializeGrid() {
  grid = [];
  for (let r = 0; r < rows; r++) {
    const row = [];
    for (let c = 0; c < cols; c++) {
      row.push({
        mine: false,
        revealed: false,
        flagged: false,
        adjacentMines: 0
      });
    }
    grid.push(row);
  }
}

function placeMines(avoidRow, avoidCol) {
  let placed = 0;
  while (placed < mineCount) {
    const r = Math.floor(Math.random() * rows);
    const c = Math.floor(Math.random() * cols);
    
    const isSafe = Math.abs(r - avoidRow) <= 1 && Math.abs(c - avoidCol) <= 1;
    
    if (!grid[r][c].mine && !isSafe) {
      grid[r][c].mine = true;
      placed++;
    }
  }
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (!grid[r][c].mine) {
        grid[r][c].adjacentMines = countAdjacentMines(r, c);
      }
    }
  }
}

function countAdjacentMines(row, col) {
  let count = 0;
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      const nr = row + dr;
      const nc = col + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
        if (grid[nr][nc].mine) count++;
      }
    }
  }
  return count;
}

// ============================================================================
// RENDERING
// ============================================================================

function renderGrid() {
  const maze = document.getElementById('maze');
  maze.innerHTML = '';
  maze.style.gridTemplateColumns = `repeat(${cols}, 32px)`;
  
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      const cell = document.createElement('div');
      cell.className = 'cell';
      cell.dataset.row = r;
      cell.dataset.col = c;
      
      const cellData = grid[r][c];
      
      const isInterfered = interferenceCells.some(pos => pos.r === r && pos.c === c);
      if (isInterfered && cellData.revealed) {
        cell.classList.add('interference');
      }
      
      const proxMine = proximityMines.find(p => p.row === r && p.col === c);
      if (proxMine && proxMine.active) {
        cell.classList.add('proximity-mine');
        cell.textContent = 'üí•';
        const countdown = document.createElement('div');
        countdown.className = 'proximity-countdown';
        countdown.textContent = proxMine.countdown;
        cell.appendChild(countdown);
      }

      if (empPowerupActive && r === empPowerupRow && c === empPowerupCol) {
        cell.classList.add('emp-powerup');
        cell.textContent = '‚ö°';
      }

      const isTrapBomb = empTrapBombs.some(bomb => bomb.row === r && bomb.col === c);
      if (isTrapBomb) {
        cell.classList.add('emp-trap-bomb');
        cell.textContent = 'üí£';
      }

      const hazard = hazardTiles.find(h => h.active && h.row === r && h.col === c);
      if (hazard) {
        if (hazard.type === 'blue') {
          cell.classList.add('blue-hazard');
          cell.textContent = 'üßä';
        } else {
          cell.classList.add('green-hazard');
          cell.textContent = 'üêå';
        }
      }
      
      if (droneActive && r === droneRow && c === droneCol) {
        cell.classList.add('drone');
        cell.textContent = 'üõ∏';
      }
      
      if (drone2Active && r === drone2Row && c === drone2Col) {
        cell.classList.add('drone');
        cell.textContent = 'üõ∏';
      }
      
      if (anomalyActive && r === anomalyRow && c === anomalyCol) {
        cell.classList.add('anomaly');
        cell.textContent = 'üîÆ';
        const countdown = document.createElement('div');
        countdown.className = 'anomaly-countdown';
        countdown.textContent = anomalyCountdown;
        cell.appendChild(countdown);
      }
      
      // Current player
      if (r === playerRow && c === playerCol) {
        cell.classList.add('player');
        if (cellData.flagged) {
          cell.classList.add('player-flagged');
        } else if (!cellData.revealed) {
          cell.textContent = 'üïµÔ∏è';
        }
      }
      
      // Other players (multiplayer only)
      if (isMultiplayer) {
        Object.entries(otherPlayers).forEach(([id, player]) => {
          if (player.row === r && player.col === c && player.alive !== false) {
            const otherPlayerSpan = document.createElement('span');
            otherPlayerSpan.textContent = 'üë§';
            otherPlayerSpan.style.position = 'absolute';
            otherPlayerSpan.style.fontSize = '1.3rem';
            otherPlayerSpan.style.filter = 'drop-shadow(0 0 3px #ff00ff)';
            otherPlayerSpan.style.zIndex = '4';
            cell.appendChild(otherPlayerSpan);
          }
        });
      }
      
      if (cellData.flagged && !(r === playerRow && c === playerCol)) {
        cell.classList.add('flagged');
      }
      
      if (cellData.revealed) {
        cell.classList.add('revealed');
        if (cellData.mine) {
          cell.innerHTML = '<span class="mine-icon">üí£</span>';
          if (gameOver && r === playerRow && c === playerCol) {
            cell.classList.add('mine-hit');
          }
        } else if (cellData.adjacentMines > 0 && !isInterfered) {
          cell.textContent = cellData.adjacentMines;
          cell.classList.add(`num-${cellData.adjacentMines}`);
        }
        
        if (r === playerRow && c === playerCol && !cellData.mine) {
          const agentSpan = document.createElement('span');
          agentSpan.textContent = 'üïµÔ∏è';
          agentSpan.style.position = 'absolute';
          agentSpan.style.fontSize = '1.3rem';
          agentSpan.style.filter = 'drop-shadow(0 0 3px #00ffcc)';
          cell.appendChild(agentSpan);
        }
      }
      
      maze.appendChild(cell);
    }
  }
  
  scrollToPlayer();
}

function scrollToPlayer() {
  setTimeout(() => {
    const playerCell = document.querySelector('.cell.player');
    if (playerCell) {
      const rect = playerCell.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const viewportWidth = window.innerWidth;
      
      if (rect.bottom > viewportHeight - 100 || rect.top < 100 ||
          rect.right > viewportWidth - 100 || rect.left < 100) {
        playerCell.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
      }
    }
  }, 50);
}

// ============================================================================
// KEYBOARD CONTROLS
// ============================================================================

document.addEventListener('keydown', (e) => {
  if (currentScreen !== 'game') {
    if ((gameOver || gameWon) && (e.key === 'r' || e.key === 'R')) {
      restartGame();
    }
    return;
  }
  
  if (gameOver || gameWon) {
    if (e.key === 'r' || e.key === 'R') {
      restartGame();
    }
    return;
  }
  
  if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
    e.preventDefault();
    
    if (playerFrozen) {
      showNotification('üßä FROZEN! Cannot move!', 'danger');
      return;
    }
    
    if (moveCooldown) return;
    
    moveCooldown = true;
    const delay = playerSlowed ? MOVE_DELAY * 3 : MOVE_DELAY;
    setTimeout(() => {
      moveCooldown = false;
    }, delay);
    
    let newRow = playerRow;
    let newCol = playerCol;
    
    switch(e.key) {
      case 'ArrowUp':
        if (playerRow > 0) newRow--;
        break;
      case 'ArrowDown':
        if (playerRow < rows - 1) newRow++;
        break;
      case 'ArrowLeft':
        if (playerCol > 0) newCol--;
        break;
      case 'ArrowRight':
        if (playerCol < cols - 1) newCol++;
        break;
    }
    
    if (newRow !== playerRow || newCol !== playerCol) {
      playerRow = newRow;
      playerCol = newCol;
      
      // Send to server if multiplayer
      if (isMultiplayer && socket && socket.readyState === WebSocket.OPEN) {
        socket.send(JSON.stringify({
          type: 'PLAYER_MOVE',
          row: playerRow,
          col: playerCol
        }));
      }
      
      checkDroneCaught();
      checkProximityMines();
      checkEMPPowerup();
      checkTrapBombs();
      checkHazardTiles();
      renderGrid();
    }
  }
  else if (e.key === ' ') {
    e.preventDefault();
    scanCurrentTile();
  }
  else if (e.key === 'f' || e.key === 'F') {
    e.preventDefault();
    toggleFlag();
  }
  else if (e.key === 'e' || e.key === 'E') {
    e.preventDefault();
    useEMP();
  }
  else if (e.key === 'r' || e.key === 'R') {
    e.preventDefault();
    restartGame();
  }
});

// ============================================================================
// PLAYER ACTIONS
// ============================================================================

function scanCurrentTile() {
  if (gameOver || gameWon) return;
  
  const cell = grid[playerRow][playerCol];
  if (cell.revealed || cell.flagged) return;
  
  // Single player - place mines on first click
  if (!isMultiplayer && firstClick) {
    placeMines(playerRow, playerCol);
    firstClick = false;
    startTimer();
  }
  
  // Multiplayer - send to server
  if (isMultiplayer && socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: 'SCAN_TILE',
      row: playerRow,
      col: playerCol
    }));
    return;
  }
  
  // Single player - handle locally
  if (cell.mine) {
    cell.revealed = true;
    gameOver = true;
    streak = 0;
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 300);
    revealAllMines();
    renderGrid();
    stopTimer();
    clearAllTimers();
    showGameOver();
    return;
  }
  
  if (anomalyActive && playerRow === anomalyRow && playerCol === anomalyCol) {
    clearInterval(anomalyCountdownInterval);
    anomalyActive = false;
    showNotification('üîÆ Anomaly Neutralized!', 'success');
  }
  
  streak++;
  updateStats();
  
  revealCell(playerRow, playerCol);
  renderGrid();
  updateStats();
  checkWin();
}

function toggleFlag() {
  if (gameOver || gameWon) return;
  
  const cell = grid[playerRow][playerCol];
  if (cell.revealed) return;
  
  // Multiplayer - send to server
  if (isMultiplayer && socket && socket.readyState === WebSocket.OPEN) {
    socket.send(JSON.stringify({
      type: 'TOGGLE_FLAG',
      row: playerRow,
      col: playerCol
    }));
    return;
  }
  
  // Single player - handle locally
  cell.flagged = !cell.flagged;
  flagCount += cell.flagged ? 1 : -1;
  
  if (anomalyActive && playerRow === anomalyRow && playerCol === anomalyCol && cell.flagged) {
    clearInterval(anomalyCountdownInterval);
    anomalyActive = false;
    showNotification('üîÆ Anomaly Neutralized!', 'success');
  }
  
  renderGrid();
  updateStats();
}

function revealCell(row, col) {
  if (row < 0 || row >= rows || col < 0 || col >= cols) return;
  
  const cell = grid[row][col];
  if (cell.revealed || cell.flagged || cell.mine) return;
  
  cell.revealed = true;
  revealedCount++;
  
  const cellElement = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
  if (cellElement) {
    cellElement.classList.add('cascade-reveal');
  }
  
  if (cell.adjacentMines === 0) {
    for (let dr = -1; dr <= 1; dr++) {
      for (let dc = -1; dc <= 1; dc++) {
        if (dr === 0 && dc === 0) continue;
        setTimeout(() => revealCell(row + dr, col + dc), 20);
      }
    }
  }
}

function revealAllMines() {
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c].mine) {
        grid[r][c].revealed = true;
      }
    }
  }
}

function checkWin() {
  const totalCells = rows * cols;
  const nonMineCells = totalCells - mineCount;
  
  if (revealedCount === nonMineCells) {
    gameWon = true;
    stopTimer();
    clearAllTimers();
    
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (grid[r][c].mine && !grid[r][c].flagged) {
          grid[r][c].flagged = true;
          flagCount++;
        }
      }
    }
    
    renderGrid();
    updateStats();
    showGameWin();
  }
}

// ============================================================================
// STATS & TIMER
// ============================================================================

function updateStats() {
  document.getElementById('mineCount').textContent = mineCount;
  document.getElementById('flagCount').textContent = flagCount;
  document.getElementById('tilesLeft').textContent = (rows * cols) - mineCount - revealedCount;
  document.getElementById('streakCount').textContent = streak;
  document.getElementById('empCharges').textContent = empCharges;
}

function startTimer() {
  timerInterval = setInterval(() => {
    timeElapsed++;
    document.getElementById('timer').textContent = String(timeElapsed).padStart(3, '0');
  }, 1000);
}

function stopTimer() {
  if (timerInterval) {
    clearInterval(timerInterval);
    timerInterval = null;
  }
}

// ============================================================================
// GAME HAZARDS & OBSTACLES
// ============================================================================

function spawnDrone() {
  if (droneActive || gameOver || gameWon) return;
  
  droneActive = true;
  showNotification('üõ∏ DRONE DETECTED! EVADE!', 'danger');
  
  const edge = Math.floor(Math.random() * 4);
  switch(edge) {
    case 0: droneRow = 0; droneCol = Math.floor(Math.random() * cols); break;
    case 1: droneRow = rows - 1; droneCol = Math.floor(Math.random() * cols); break;
    case 2: droneRow = Math.floor(Math.random() * rows); droneCol = 0; break;
    case 3: droneRow = Math.floor(Math.random() * rows); droneCol = cols - 1; break;
  }
  
  renderGrid();
  
  droneInterval = setInterval(() => {
    if (!droneActive || gameOver || gameWon) return;
    
    if (droneRow < playerRow) droneRow++;
    else if (droneRow > playerRow) droneRow--;
    else if (droneCol < playerCol) droneCol++;
    else if (droneCol > playerCol) droneCol--;
    
    checkDroneCaught();
    renderGrid();
  }, 600);
}

function spawnDrone2() {
  if (drone2Active || gameOver || gameWon) return;
  
  drone2Active = true;
  showNotification('üõ∏üõ∏ SECOND DRONE DEPLOYED!', 'danger');
  
  const edge = Math.floor(Math.random() * 4);
  switch(edge) {
    case 0: drone2Row = 0; drone2Col = Math.floor(Math.random() * cols); break;
    case 1: drone2Row = rows - 1; drone2Col = Math.floor(Math.random() * cols); break;
    case 2: drone2Row = Math.floor(Math.random() * rows); drone2Col = 0; break;
    case 3: drone2Row = Math.floor(Math.random() * rows); drone2Col = cols - 1; break;
  }
  
  renderGrid();
  
  drone2Interval = setInterval(() => {
    if (!drone2Active || gameOver || gameWon) return;
    
    if (drone2Row < playerRow) drone2Row++;
    else if (drone2Row > playerRow) drone2Row--;
    else if (drone2Col < playerCol) drone2Col++;
    else if (drone2Col > playerCol) drone2Col--;
    
    checkDroneCaught();
    renderGrid();
  }, 500);
}

function checkDroneCaught() {
  if (droneActive && droneRow === playerRow && droneCol === playerCol) {
    gameOver = true;
    droneActive = false;
    drone2Active = false;
    
    showNotification('üõ∏ DRONE CAPTURED YOU! MISSION FAILED!', 'danger');
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 300);
    
    revealAllMines();
    renderGrid();
    stopTimer();
    clearAllTimers();
    
    setTimeout(() => {
      document.getElementById('failTime').textContent = timeElapsed;
      document.getElementById('failStreak').textContent = streak;
      const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
      modal.show();
    }, 500);
    
    return;
  }
  
  if (drone2Active && drone2Row === playerRow && drone2Col === playerCol) {
    gameOver = true;
    droneActive = false;
    drone2Active = false;
    
    showNotification('üõ∏ DRONE 2 CAPTURED YOU! MISSION FAILED!', 'danger');
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 300);
    
    revealAllMines();
    renderGrid();
    stopTimer();
    clearAllTimers();
    
    setTimeout(() => {
      document.getElementById('failTime').textContent = timeElapsed;
      document.getElementById('failStreak').textContent = streak;
      const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
      modal.show();
    }, 500);
  }
}

function spawnAnomaly() {
  if (anomalyActive || gameOver || gameWon) return;
  
  const revealedTiles = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c].revealed) {
        revealedTiles.push({r, c});
      }
    }
  }
  
  if (revealedTiles.length === 0) return;
  
  const randomRevealed = revealedTiles[Math.floor(Math.random() * revealedTiles.length)];
  
  const candidates = [];
  for (let dr = -4; dr <= 4; dr++) {
    for (let dc = -4; dc <= 4; dc++) {
      const nr = randomRevealed.r + dr;
      const nc = randomRevealed.c + dc;
      const distance = Math.abs(dr) + Math.abs(dc);
      
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && 
          !grid[nr][nc].revealed && distance >= 2 && distance <= 4) {
        candidates.push({r: nr, c: nc});
      }
    }
  }
  
  if (candidates.length === 0) return;
  
  const chosen = candidates[Math.floor(Math.random() * candidates.length)];
  anomalyRow = chosen.r;
  anomalyCol = chosen.c;
  anomalyActive = true;
  anomalyCountdown = 6;
  
  showNotification('üîÆ Anomaly Detected! Re-covering in 6s...', 'info');
  renderGrid();
  
  if (anomalyCountdownInterval) clearInterval(anomalyCountdownInterval);
  anomalyCountdownInterval = setInterval(() => {
    anomalyCountdown--;
    if (anomalyCountdown <= 0) {
      triggerAnomalyRecover();
    } else {
      renderGrid();
    }
  }, 1000);
}

function triggerAnomalyRecover() {
  if (!anomalyActive) return;
  
  clearInterval(anomalyCountdownInterval);
  anomalyActive = false;
  
  showNotification('üîÆ ANOMALY RE-COVERED AREA!', 'warning');
  
  const recoveredCells = [];
  
  for (let dr = -2; dr <= 2; dr++) {
    for (let dc = -2; dc <= 2; dc++) {
      const nr = anomalyRow + dr;
      const nc = anomalyCol + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
        const cell = grid[nr][nc];
        
        if (cell.revealed && !cell.mine) {
          cell.revealed = false;
          revealedCount--;
          recoveredCells.push({row: nr, col: nc});
        }
      }
    }
  }
  
  recoveredCells.forEach((pos, index) => {
    setTimeout(() => {
      const cellElement = document.querySelector(`[data-row="${pos.row}"][data-col="${pos.col}"]`);
      if (cellElement) {
        cellElement.classList.add('anomaly-transform');
        setTimeout(() => cellElement.classList.remove('anomaly-transform'), 800);
      }
    }, index * 30);
  });
  
  renderGrid();
  updateStats();
}

function spawnProximityMine() {
  if (gameOver || gameWon) return;
  
  let validSpawn = false;
  let spawnRow, spawnCol;
  
  while (!validSpawn) {
    spawnRow = Math.floor(Math.random() * rows);
    spawnCol = Math.floor(Math.random() * cols);
    const distance = Math.abs(spawnRow - playerRow) + Math.abs(spawnCol - playerCol);
    
    if (distance >= 5 && !grid[spawnRow][spawnCol].revealed) {
      validSpawn = true;
    }
  }
  
  const proxMine = {
    row: spawnRow,
    col: spawnCol,
    countdown: 4,
    active: true
  };
  
  proximityMines.push(proxMine);
  showNotification('üí• PROXIMITY MINE DETECTED!', 'danger');
  renderGrid();
  
  const countdownInterval = setInterval(() => {
    if (gameOver || gameWon || !proxMine.active) {
      clearInterval(countdownInterval);
      return;
    }
    
    const distance = Math.abs(proxMine.row - playerRow) + Math.abs(proxMine.col - playerCol);
    
    if (distance <= 3) {
      proxMine.countdown--;
      if (proxMine.countdown <= 0) {
        detonateProximityMine(proxMine);
        clearInterval(countdownInterval);
      }
    } else {
      proxMine.countdown = 4;
    }
    
    renderGrid();
  }, 1000);
}

function detonateProximityMine(proxMine) {
  proxMine.active = false;
  
  const playerDistance = Math.max(
    Math.abs(proxMine.row - playerRow),
    Math.abs(proxMine.col - playerCol)
  );
  
  if (playerDistance <= 2) {
    gameOver = true;
    
    showNotification('üí• PROXIMITY MINE KILLED YOU! MISSION FAILED!', 'danger');
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 300);
    
    revealAllMines();
    renderGrid();
    stopTimer();
    clearAllTimers();
    
    setTimeout(() => {
      document.getElementById('failTime').textContent = timeElapsed;
      document.getElementById('failStreak').textContent = streak;
      const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
      modal.show();
    }, 500);
    
    return;
  }
  
  showNotification('üí• PROXIMITY MINE DETONATED!', 'danger');
  document.body.classList.add('shake');
  setTimeout(() => document.body.classList.remove('shake'), 300);
  
  for (let dr = -2; dr <= 2; dr++) {
    for (let dc = -2; dc <= 2; dc++) {
      const nr = proxMine.row + dr;
      const nc = proxMine.col + dc;
      if (nr >= 0 && nr < rows && nc >= 0 && nc < cols) {
        const cell = grid[nr][nc];
        if (cell.revealed && !cell.mine) {
          cell.revealed = false;
          revealedCount--;
        }
      }
    }
  }
  
  renderGrid();
  updateStats();
}

function checkProximityMines() {
  proximityMines.forEach(proxMine => {
    if (!proxMine.active) return;
    const distance = Math.abs(proxMine.row - playerRow) + Math.abs(proxMine.col - playerCol);
    
    if (distance <= 3 && proxMine.countdown === 4) {
      showNotification('‚ö†Ô∏è PROXIMITY MINE ARMED!', 'warning');
    }
  });
}

function triggerStaticInterference() {
  if (gameOver || gameWon || staticInterferenceActive) return;
  
  staticInterferenceActive = true;
  interferenceCells = [];
  
  const revealedTiles = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (grid[r][c].revealed) {
        revealedTiles.push({r, c});
      }
    }
  }
  
  const count = Math.min(9 + Math.floor(Math.random() * 6), revealedTiles.length);
  for (let i = 0; i < count; i++) {
    const randomIndex = Math.floor(Math.random() * revealedTiles.length);
    interferenceCells.push(revealedTiles.splice(randomIndex, 1)[0]);
  }
  
  showNotification('‚ö° STATIC INTERFERENCE!', 'warning');
  renderGrid();
  
  setTimeout(() => {
    staticInterferenceActive = false;
    interferenceCells = [];
    renderGrid();
  }, 10000);
}

function triggerEMPBlackout() {
  if (gameOver || gameWon || empBlackoutActive) return;
  
  empBlackoutActive = true;
  document.getElementById('maze').classList.add('emp-blackout');
  showNotification('üåë EMP BLACKOUT!', 'danger');
  
  setTimeout(() => {
    empBlackoutActive = false;
    document.getElementById('maze').classList.remove('emp-blackout');
  }, 6000);
}

function spawnHazardTile() {
  if (gameOver || gameWon) return;
  
  const isBlue = Math.random() < 0.5;
  const type = isBlue ? 'blue' : 'green';
  
  let validSpawn = false;
  let spawnRow, spawnCol;
  let attempts = 0;
  
  while (!validSpawn && attempts < 100) {
    spawnRow = Math.floor(Math.random() * rows);
    spawnCol = Math.floor(Math.random() * cols);
    const distance = Math.abs(spawnRow - playerRow) + Math.abs(spawnCol - playerCol);
    
    if (!grid[spawnRow][spawnCol].revealed && distance >= 3) {
      validSpawn = true;
    }
    attempts++;
  }
  
  if (!validSpawn) return;
  
  const hazard = {
    row: spawnRow,
    col: spawnCol,
    type: type,
    active: true
  };
  
  hazardTiles.push(hazard);
  
  if (type === 'blue') {
    showNotification('üßä FREEZE HAZARD SPAWNED!', 'info');
  } else {
    showNotification('üêå SLOW HAZARD SPAWNED!', 'info');
  }
  
  renderGrid();
  
  setTimeout(() => {
    hazard.active = false;
    const index = hazardTiles.indexOf(hazard);
    if (index > -1) {
      hazardTiles.splice(index, 1);
    }
    renderGrid();
  }, 10000);
}

function checkHazardTiles() {
  hazardTiles.forEach(hazard => {
    if (!hazard.active) return;
    
    if (hazard.row === playerRow && hazard.col === playerCol) {
      hazard.active = false;
      const index = hazardTiles.indexOf(hazard);
      if (index > -1) {
        hazardTiles.splice(index, 1);
      }
      
      if (hazard.type === 'blue') {
        playerFrozen = true;
        showNotification('üßä FROZEN! Can\'t move for 1s!', 'warning');
        setTimeout(() => {
          playerFrozen = false;
          if (!gameOver && !gameWon) {
            showNotification('‚úì Freeze ended', 'success');
          }
        }, 1000);
      } else {
        playerSlowed = true;
        showNotification('üêå SLOWED! Movement delayed for 4s!', 'warning');
        setTimeout(() => {
          playerSlowed = false;
          if (!gameOver && !gameWon) {
            showNotification('‚úì Slow effect ended', 'success');
          }
        }, 4000);
      }
    }
  });
}

// ============================================================================
// EMP POWERUP
// ============================================================================

function spawnEMPPowerup() {
  if (empPowerupActive || gameOver || gameWon) return;
  
  let validSpawn = false;
  let spawnRow, spawnCol;
  let attempts = 0;
  
  while (!validSpawn && attempts < 100) {
    spawnRow = Math.floor(Math.random() * rows);
    spawnCol = Math.floor(Math.random() * cols);
    const distance = Math.abs(spawnRow - playerRow) + Math.abs(spawnCol - playerCol);
    
    const hasRoom = spawnRow > 0 && spawnRow < rows - 1 && 
                    spawnCol > 0 && spawnCol < cols - 1;
    
    if (hasRoom && !grid[spawnRow][spawnCol].revealed && distance >= 4) {
      validSpawn = true;
    }
    attempts++;
  }
  
  if (!validSpawn) return;
  
  empPowerupRow = spawnRow;
  empPowerupCol = spawnCol;
  empPowerupActive = true;
  empTrapBombs = [];
  
  const adjacentPositions = [];
  for (let dr = -1; dr <= 1; dr++) {
    for (let dc = -1; dc <= 1; dc++) {
      if (dr === 0 && dc === 0) continue;
      adjacentPositions.push({
        row: spawnRow + dr,
        col: spawnCol + dc
      });
    }
  }
  
  const shuffled = adjacentPositions.sort(() => Math.random() - 0.5);
  const safePositions = shuffled.slice(0, 3);
  
  adjacentPositions.forEach(pos => {
    if (!safePositions.some(safe => safe.row === pos.row && safe.col === pos.col)) {
      empTrapBombs.push(pos);
    }
  });
  
  showNotification('‚ö° EMP POWERUP SPAWNED! Beware of traps!', 'warning');
  renderGrid();
  
  if (empPowerupTimeout) clearTimeout(empPowerupTimeout);
  empPowerupTimeout = setTimeout(() => {
    if (empPowerupActive && !gameOver && !gameWon) {
      empPowerupActive = false;
      empTrapBombs = [];
      empPowerupTimeout = null;
      showNotification('‚ö° EMP POWERUP EXPIRED!', 'warning');
      renderGrid();
    }
  }, 12000);
}

function useEMP() {
  if (empCharges <= 0) {
    showNotification('‚ö° No EMP charges available!', 'danger');
    return;
  }
  
  empCharges--;
  updateStats();
  
  showNotification('‚ö° EMP ACTIVATED! Drones disabled for 8s!', 'success');
  
  const wasDroneActive = droneActive;
  const wasDrone2Active = drone2Active;
  
  droneActive = false;
  drone2Active = false;
  
  if (droneInterval) {
    clearInterval(droneInterval);
    droneInterval = null;
  }
  if (drone2Interval) {
    clearInterval(drone2Interval);
    drone2Interval = null;
  }
  
  renderGrid();
  
  setTimeout(() => {
    if (wasDroneActive && !gameOver && !gameWon) {
      droneActive = true;
      droneInterval = setInterval(() => {
        if (!droneActive || gameOver || gameWon) return;
        
        if (droneRow < playerRow) droneRow++;
        else if (droneRow > playerRow) droneRow--;
        else if (droneCol < playerCol) droneCol++;
        else if (droneCol > playerCol) droneCol--;
        
        checkDroneCaught();
        renderGrid();
      }, 600);
    }
    
    if (wasDrone2Active && !gameOver && !gameWon) {
      drone2Active = true;
      drone2Interval = setInterval(() => {
        if (!drone2Active || gameOver || gameWon) return;
        
        if (drone2Row < playerRow) drone2Row++;
        else if (drone2Row > playerRow) drone2Row--;
        else if (drone2Col < playerCol) drone2Col++;
        else if (drone2Col > playerCol) drone2Col--;
        
        checkDroneCaught();
        renderGrid();
      }, 500);
    }
    
    if ((wasDroneActive || wasDrone2Active) && !gameOver && !gameWon) {
      showNotification('‚ö° EMP effect worn off!', 'warning');
    }
  }, 8000);
}

function checkEMPPowerup() {
  if (empPowerupActive && playerRow === empPowerupRow && playerCol === empPowerupCol) {
    empPowerupActive = false;
    empCharges++;
    empTrapBombs = [];
    
    if (empPowerupTimeout) {
      clearTimeout(empPowerupTimeout);
      empPowerupTimeout = null;
    }
    
    showNotification('‚ö° EMP CHARGE COLLECTED! Press E to use!', 'success');
    updateStats();
  }
}

function checkTrapBombs() {
  const hitTrapBomb = empTrapBombs.find(bomb => bomb.row === playerRow && bomb.col === playerCol);
  
  if (hitTrapBomb) {
    gameOver = true;
    empPowerupActive = false;
    empTrapBombs = [];
    
    if (empPowerupTimeout) {
      clearTimeout(empPowerupTimeout);
      empPowerupTimeout = null;
    }
    
    showNotification('üí• TRAP BOMB DETONATED! MISSION FAILED!', 'danger');
    document.body.classList.add('shake');
    setTimeout(() => document.body.classList.remove('shake'), 300);
    
    revealAllMines();
    renderGrid();
    stopTimer();
    clearAllTimers();
    
    setTimeout(() => {
      document.getElementById('failTime').textContent = timeElapsed;
      document.getElementById('failStreak').textContent = streak;
      const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
      modal.show();
    }, 500);
  }
}

// ============================================================================
// UI & NOTIFICATIONS
// ============================================================================

function showNotification(message, type = 'info') {
  const notif = document.createElement('div');
  notif.className = `notification ${type}`;
  notif.textContent = message;
  document.body.appendChild(notif);
  
  setTimeout(() => {
    notif.style.animation = 'slideDown 0.3s ease reverse';
    setTimeout(() => notif.remove(), 300);
  }, 3000);
}

function showGameOver() {
  setTimeout(() => {
    document.getElementById('failTime').textContent = timeElapsed;
    document.getElementById('failStreak').textContent = streak;
    const modal = new bootstrap.Modal(document.getElementById('gameOverModal'));
    modal.show();
  }, 500);
}

function showGameWin() {
  setTimeout(() => {
    document.getElementById('winTime').textContent = timeElapsed;
    document.getElementById('winStreak').textContent = streak;
    const modal = new bootstrap.Modal(document.getElementById('gameWinModal'));
    modal.show();
  }, 300);
}

function triggerFlash() {
  const flash = document.getElementById('flash');
  flash.style.opacity = '1';
  setTimeout(() => {
    flash.style.opacity = '0';
  }, 200);
}

function restartGame() {
  triggerFlash();
  setTimeout(() => {
    currentScreen = 'game';
    if (isMultiplayer) {
      // Can't restart in multiplayer
      showNotification('Cannot restart in multiplayer mode', 'warning');
      return;
    }
    startGame(rows, cols, mineCount);
  }, 200);
}

// ============================================================================
// BUTTON HANDLERS
// ============================================================================

document.getElementById('retryBtn').addEventListener('click', () => {
  if (isMultiplayer) {
    document.getElementById('gameScreen').classList.add('d-none');
    document.getElementById('lobbyScreen').classList.remove('d-none');
    currentScreen = 'lobby';
  } else {
    startGame(rows, cols, mineCount);
  }
});

document.getElementById('playAgainBtn').addEventListener('click', () => {
  if (isMultiplayer) {
    document.getElementById('gameScreen').classList.add('d-none');
    document.getElementById('lobbyScreen').classList.remove('d-none');
    currentScreen = 'lobby';
  } else {
    startGame(rows, cols, mineCount);
  }
});

document.getElementById('newGameBtn').addEventListener('click', () => {
  currentScreen = 'title';
  document.getElementById('gameScreen').classList.add('d-none');
  document.getElementById('titleScreen').classList.remove('d-none');
  stopTimer();
  clearAllTimers();
});

</script>
</body>
</html>